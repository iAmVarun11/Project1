From mongodb compass shell :
use quiz_master
switched to db quiz_master
show collections
assignments
quizzes
results
users
for (const coll of db.getCollectionNames()) {
  print("\n====================================");
  print("Collection: " + coll);
  
  const docs = db.getCollection(coll).aggregate([
    { $sample: { size: 50 } },  // take up to 50 docs to infer schema
    { $project: { doc: { $objectToArray: "$$ROOT" } } },
    { $unwind: "$doc" },
    { $group: { _id: "$doc.k", types: { $addToSet: { $type: "$doc.v" } } } },
    { $sort: { _id: 1 } }
  ]).toArray();

  docs.forEach(doc => {
    print(`${doc._id}: ${doc.types.join(", ")}`);
  });
}

====================================
Collection: assignments

====================================
Collection: users
__v: int
_id: objectId
createdAt: date
email: string
name: string
passwordHash: string
role: string
updatedAt: date

====================================
Collection: results

====================================
Collection: quizzes
quiz_master

tree :
D:\Demo\quiz_master\quiz_master>tree /F
Folder PATH listing for volume New Volume
Volume serial number is 4C44-97C0
D:.
├───BACKEND
│   │   .env
│   │   package.json
│   │   README.md
│   │
│   └───src
│       │   server.js
│       │
│       ├───config
│       │       db.js
│       │
│       ├───controllers
│       │       assignment.controller.js
│       │       auth.controller.js
│       │       public.controller.js
│       │       quiz.controller.js
│       │       result.controller.js
│       │       user.controller.js
│       │
│       ├───middleware
│       │       auth.js
│       │       error.js
│       │
│       ├───models
│       │       Assignment.js
│       │       Quiz.js
│       │       Result.js
│       │       User.js
│       │
│       └───routes
│               assignment.routes.js
│               auth.routes.js
│               public.routes.js
│               quiz.routes.js
│               result.routes.js
│               user.routes.js
│
└───FRONTEND
    │   .gitignore
    │   .hintrc
    │   env.example
    │   eslint.config.js
    │   index.html
    │   package.json
    │   README.md
    │   vite.config.js
    │
    ├───.vscode
    │       settings.json
    │
    ├───public
    │       vite.svg
    │
    └───src
        │   App.jsx
        │   App.zip
        │   index.css
        │   main.jsx
        │
        ├───api
        │       auth.js
        │       http.js
        │       public.js
        │       quizzes.js
        │       results.js
        │
        ├───assets
        │       arrow.jpg
        │       book.jpg
        │       box.jpg
        │       bronz.png
        │       cal.jpg
        │       chat.png
        │       chemistry.jpeg
        │       excal.jpg
        │       generated-image (3).png
        │       generated-image (4).png
        │       gold.png
        │       logo.jpg
        │       maths.png
        │       medal.jpg
        │       notification.png
        │       phy.jpg
        │       quiz-graphic.png
        │       react.svg
        │       silver.png
        │       st.jpg
        │       stack_book.png
        │       student.jpg
        │       trophy.jpg
        │       UserLogo.jpg
        │
        ├───components
        │   │   ChatWindow.jsx
        │   │   CTA.jsx
        │   │   ErrorBoundary.jsx
        │   │   Features.jsx
        │   │   Footer.jsx
        │   │   Navbar.jsx
        │   │   ProtectedRoute.jsx
        │   │   QuizCard.jsx
        │   │   Sidebar.jsx
        │   │   SkeletonTable.jsx
        │   │   Spinner.jsx
        │   │
        │   └───images
        │           arrow.jpg
        │           book.jpg
        │           box.jpg
        │           cal.jpg
        │           excal.jpg
        │           Logo.jpg
        │           medal.jpg
        │           st.jpg
        │           student.jpg
        │           trophy.jpg
        │           UserLogo.jpg
        │
        ├───context
        │       AuthContext.jsx
        │
        ├───pages
        │       AdminDashboard.jsx
        │       AssignQuizPage.jsx
        │       CreateQuizPage.jsx
        │       DetailedResultViewPage.jsx
        │       EditProfilePage.jsx
        │       LandingPage.jsx
        │       LoginPage.jsx
        │       PublicQuizzesPage.jsx
        │       QuestionBankPage.jsx
        │       QuizListPage.jsx
        │       QuizResultPage.jsx
        │       SignUpPage.jsx
        │       StudentChatInterface.jsx
        │       StudentDashboard.jsx
        │       StudentManagementPage.jsx
        │       TakeQuizPage.jsx
        │       TeacherChatInterface.jsx
        │       TeacherDashboard.jsx
        │       ViewStudentResultsPage.jsx
        │
        └───styles
                AdminDashboard.css
                AssignQuizPage.css
                ChatWindow.css
                CreateQuizPage.css
                CTA.css
                DetailedResultViewPage.css
                EditProfilePage.css
                Features.css
                Footer.css
                LandingPage.css
                LoginPage.css
                Navbar.css
                QuestionBankPage.css
                QuizCard.css
                QuizListPage.css
                QuizResultPage.css
                Sidebar.css
                SignUpPage.css
                StudentChatInterface.css
                StudentDashboard.css
                StudentManagementPage.css
                TakeQuizPage.css
                TeacherChatInterface.css
                TeacherDashboard.css
                ViewStudentResultsPage.css


D:\Demo\quiz_master\quiz_master>

Backend:

/backend/src/config/db.js:
import mongoose from 'mongoose';

export async function connectToDatabase() {
	const mongoUri = process.env.MONGODB_URI;
	if (!mongoUri) {
		throw new Error('MONGODB_URI is not defined');
	}
	mongoose.set('strictQuery', true);
	await mongoose.connect(mongoUri, {
		autoIndex: true
	});
}

/backend/src/controllers/assignment.controller.js:
import { body, validationResult } from 'express-validator';
import Assignment from '../models/Assignment.js';

export const validateAssignment = [
	body('quiz').isString().isLength({ min: 1 }),
	body('assignedTo').isArray(),
	body('assignedTo.*').isString(),
	body('dueDate').optional().isISO8601().toDate(),
	body('notes').optional().isString()
];

export async function createAssignment(req, res) {
	const errors = validationResult(req);
	if (!errors.isEmpty()) {
		return res.status(400).json({ errors: errors.array() });
	}
	const { quiz, assignedTo, dueDate, notes } = req.body;
	const assignment = await Assignment.create({
		quiz,
		assignedTo,
		dueDate,
		notes,
		assignedBy: req.user._id
	});
	return res.status(201).json({ assignment });
}

export async function listAssignments(req, res) {
	const filter = {};
	if (req.user.role === 'teacher') {
		filter.assignedBy = req.user._id;
	}
	if (req.user.role === 'student') {
		filter.assignedTo = req.user._id;
	}
	const assignments = await Assignment.find(filter)
		.populate('quiz', 'title description')
		.populate('assignedBy', 'name email')
		.populate('assignedTo', 'name email')
		.sort({ createdAt: -1 });
	return res.json({ assignments });
}

export async function deleteAssignment(req, res) {
	const { id } = req.params;
	const assignment = await Assignment.findById(id);
	if (!assignment) {
		return res.status(404).json({ message: 'Assignment not found' });
	}
	if (req.user.role !== 'admin' && assignment.assignedBy.toString() !== req.user._id.toString()) {
		return res.status(403).json({ message: 'Forbidden' });
	}
	await assignment.deleteOne();
	return res.json({ ok: true });
}




/backend/src/controllers/auth.controller.js:
import jwt from 'jsonwebtoken';
import { body, validationResult } from 'express-validator';
import User from '../models/User.js';

export const validateRegister = [
	body('name').isString().trim().isLength({ min: 2 }),
	body('email').isEmail().normalizeEmail(),
	body('password').isLength({ min: 6 }),
	body('role').optional().isIn(['admin', 'teacher', 'student'])
];

export const validateLogin = [body('email').isEmail().normalizeEmail(), body('password').isString()];

function signToken(userId) {
	return jwt.sign({ id: userId }, process.env.JWT_SECRET, { expiresIn: '7d' });
}

export async function register(req, res) {
	const errors = validationResult(req);
	if (!errors.isEmpty()) {
		return res.status(400).json({ errors: errors.array() });
	}
	const { name, email, password, role } = req.body;
	const existing = await User.findOne({ email });
	if (existing) {
		return res.status(409).json({ message: 'Email already registered' });
	}
	const passwordHash = await User.hashPassword(password);
	const user = await User.create({ name, email, passwordHash, role: role || 'student' });
	const token = signToken(user._id.toString());
	return res.status(201).json({
		token,
		user: { id: user._id, name: user.name, email: user.email, role: user.role }
	});
}

export async function login(req, res) {
	const errors = validationResult(req);
	if (!errors.isEmpty()) {
		return res.status(400).json({ errors: errors.array() });
	}
	const { email, password } = req.body;
	const user = await User.findOne({ email });
	if (!user) {
		return res.status(401).json({ message: 'Invalid credentials' });
	}
	const ok = await user.comparePassword(password);
	if (!ok) {
		return res.status(401).json({ message: 'Invalid credentials' });
	}
	const token = signToken(user._id.toString());
	return res.json({
		token,
		user: { id: user._id, name: user.name, email: user.email, role: user.role }
	});
}

export async function me(req, res) {
	const user = req.user;
	return res.json({ user });
}

export const validateUpdateMe = [
	body('name').optional().isString().trim().isLength({ min: 2 }),
	body('password').optional().isLength({ min: 6 })
];

export async function updateMe(req, res) {
	const errors = validationResult(req);
	if (!errors.isEmpty()) {
		return res.status(400).json({ errors: errors.array() });
	}
	const { name, password } = req.body;
	const updates = {};
	if (typeof name === 'string' && name.trim()) {
		updates.name = name.trim();
	}
	if (typeof password === 'string' && password.length >= 6) {
		updates.passwordHash = await User.hashPassword(password);
	}
	if (Object.keys(updates).length === 0) {
		return res.status(400).json({ message: 'No valid fields to update' });
	}
	const updated = await User.findByIdAndUpdate(req.user._id, { $set: updates }, { new: true }).select(
		'-passwordHash'
	);
	return res.json({ user: updated });
}




/backend/src/controllers/public.controller.js:
import Quiz from '../models/Quiz.js';

export async function listPublicQuizzes(req, res) {
	const { subject } = req.query;
	const filter = { isPublished: true };
	if (subject) {
		filter.subject = subject;
	}
	const quizzes = await Quiz.find(filter)
		.select('title description subject createdAt')
		.sort({ createdAt: -1 });
	return res.json({ quizzes });
}




/backend/src/controllers/quiz.controller.js:

import { body, validationResult } from 'express-validator';
import Quiz from '../models/Quiz.js';

export const validateQuiz = [
	body('title').isString().trim().isLength({ min: 2 }),
	body('description').optional().isString(),
	body('questions').isArray(),
	body('questions.*.text').isString().isLength({ min: 1 }),
	body('questions.*.options').isArray({ min: 2 }),
	body('questions.*.options.*.text').isString().isLength({ min: 1 }),
	body('questions.*.correctOptionIndex').isInt({ min: 0 }),
	body('questions.*.points').optional().isInt({ min: 0 }),
	body('settings').optional().isObject()
];

export async function createQuiz(req, res) {
	const errors = validationResult(req);
	if (!errors.isEmpty()) {
		return res.status(400).json({ errors: errors.array() });
	}
	const payload = req.body;
	const quiz = await Quiz.create({ ...payload, createdBy: req.user._id });
	return res.status(201).json({ quiz });
}

export async function listQuizzes(req, res) {
	const filter = {};
	if (req.user.role === 'teacher') {
		filter.createdBy = req.user._id;
	}
	const quizzes = await Quiz.find(filter).populate('createdBy', 'name email role').sort({ createdAt: -1 });
	return res.json({ quizzes });
}

export async function getQuiz(req, res) {
	const { id } = req.params;
	const quiz = await Quiz.findById(id).populate('createdBy', 'name email role');
	if (!quiz) {
		return res.status(404).json({ message: 'Quiz not found' });
	}
	return res.json({ quiz });
}

export async function updateQuiz(req, res) {
	const { id } = req.params;
	const quiz = await Quiz.findById(id);
	if (!quiz) {
		return res.status(404).json({ message: 'Quiz not found' });
	}
	if (req.user.role !== 'admin' && quiz.createdBy.toString() !== req.user._id.toString()) {
		return res.status(403).json({ message: 'Forbidden' });
	}
	const updates = req.body;
	Object.assign(quiz, updates);
	await quiz.save();
	return res.json({ quiz });
}

export async function deleteQuiz(req, res) {
	const { id } = req.params;
	const quiz = await Quiz.findById(id);
	if (!quiz) {
		return res.status(404).json({ message: 'Quiz not found' });
	}
	if (req.user.role !== 'admin' && quiz.createdBy.toString() !== req.user._id.toString()) {
		return res.status(403).json({ message: 'Forbidden' });
	}
	await quiz.deleteOne();
	return res.json({ ok: true });
}



/backend/src/controllers/result.controller.js:
import { body, validationResult } from 'express-validator';
import Result from '../models/Result.js';
import Quiz from '../models/Quiz.js';

export const validateSubmission = [
	body('quizId').isString().isLength({ min: 1 }),
	body('answers').isArray(),
	body('answers.*.questionId').isString().isLength({ min: 1 }),
	body('answers.*.selectedOptionIndex').isInt({ min: 0 })
];

function scoreQuiz(quiz, answers) {
	const questionIdToQuestion = new Map();
	for (const q of quiz.questions) {
		questionIdToQuestion.set(q._id.toString(), q);
	}
	let score = 0;
	for (const a of answers) {
		const q = questionIdToQuestion.get(a.questionId.toString());
		if (!q) continue;
		if (a.selectedOptionIndex === q.correctOptionIndex) {
			score += q.points ?? 1;
		}
	}
	return score;
}

export async function submitResult(req, res) {
	const errors = validationResult(req);
	if (!errors.isEmpty()) {
		return res.status(400).json({ errors: errors.array() });
	}
	const { quizId, answers, startedAt } = req.body;
	const quiz = await Quiz.findById(quizId);
	if (!quiz) {
		return res.status(404).json({ message: 'Quiz not found' });
	}
	const score = scoreQuiz(quiz, answers);
	const result = await Result.create({
		quiz: quizId,
		user: req.user._id,
		answers,
		score,
		startedAt: startedAt ? new Date(startedAt) : undefined,
		submittedAt: new Date()
	});
	return res.status(201).json({ result });
}

export async function myResults(req, res) {
	const results = await Result.find({ user: req.user._id })
		.populate('quiz', 'title description')
		.sort({ createdAt: -1 });
	return res.json({ results });
}

export async function resultsForQuiz(req, res) {
	const { quizId } = req.params;
	const quiz = await Quiz.findById(quizId);
	if (!quiz) {
		return res.status(404).json({ message: 'Quiz not found' });
	}
	if (req.user.role !== 'admin' && quiz.createdBy.toString() !== req.user._id.toString()) {
		return res.status(403).json({ message: 'Forbidden' });
	}
	const results = await Result.find({ quiz: quizId })
		.populate('user', 'name email')
		.sort({ createdAt: -1 });
	return res.json({ results });
}




/backend/src/controllers/user.controller.js:

import User from '../models/User.js';

export async function listUsers(_req, res) {
	const users = await User.find().select('-passwordHash').sort({ createdAt: -1 });
	return res.json({ users });
}

export async function updateUser(req, res) {
	const { id } = req.params;
	const { name, role } = req.body;
	const updated = await User.findByIdAndUpdate(
		id,
		{ $set: { name, role } },
		{ new: true, runValidators: true }
	).select('-passwordHash');
	if (!updated) {
		return res.status(404).json({ message: 'User not found' });
	}
	return res.json({ user: updated });
}

export async function deleteUser(req, res) {
	const { id } = req.params;
	const deleted = await User.findByIdAndDelete(id);
	if (!deleted) {
		return res.status(404).json({ message: 'User not found' });
	}
	return res.json({ ok: true });
}



/backend/src/middleware/auth.js:
import jwt from 'jsonwebtoken';
import User from '../models/User.js';

export async function authenticate(req, res, next) {
	try {
		const authHeader = req.headers.authorization || '';
		const token = authHeader.startsWith('Bearer ') ? authHeader.substring(7) : null;
		if (!token) {
			return res.status(401).json({ message: 'Authentication required' });
		}
		const decoded = jwt.verify(token, process.env.JWT_SECRET);
		const user = await User.findById(decoded.id).select('-passwordHash');
		if (!user) {
			return res.status(401).json({ message: 'Invalid token' });
		}
		req.user = user;
		next();
	} catch (err) {
		return res.status(401).json({ message: 'Unauthorized' });
	}
}

export function authorizeRoles(...roles) {
	return (req, res, next) => {
		if (!req.user || !roles.includes(req.user.role)) {
			return res.status(403).json({ message: 'Forbidden' });
		}
		next();
	};
}

/backend/src/middleware/error.js:

export function notFoundHandler(_req, res, _next) {
	return res.status(404).json({ message: 'Route not found' });
}

// eslint-disable-next-line no-unused-vars
export function errorHandler(err, _req, res, _next) {
	// eslint-disable-next-line no-console
	console.error(err);
	const status = err.status || 500;
	const message = err.message || 'Internal Server Error';
	return res.status(status).json({ message });
}


/backend/src/models/Assignment.js:
import mongoose from 'mongoose';

const AssignmentSchema = new mongoose.Schema(
	{
		quiz: { type: mongoose.Schema.Types.ObjectId, ref: 'Quiz', required: true, index: true },
		assignedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
		assignedTo: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true }],
		dueDate: { type: Date },
		notes: { type: String }
	},
	{ timestamps: true }
);

export default mongoose.model('Assignment', AssignmentSchema);


/backend/src/models/Quiz.js:

import mongoose from 'mongoose';

const OptionSchema = new mongoose.Schema(
	{
		text: { type: String, required: true }
	},
	{ _id: false }
);

const QuestionSchema = new mongoose.Schema(
	{
		text: { type: String, required: true },
		options: { type: [OptionSchema], validate: (v) => Array.isArray(v) && v.length >= 2 },
		correctOptionIndex: { type: Number, required: true, min: 0 },
		points: { type: Number, default: 1 }
	},
	{ _id: true }
);

const QuizSchema = new mongoose.Schema(
	{
		title: { type: String, required: true, trim: true },
		description: { type: String, trim: true },
		subject: { type: String, trim: true, index: true },
		createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
		questions: { type: [QuestionSchema], default: [] },
		settings: {
			timeLimitMinutes: { type: Number, default: 0 },
			shuffleQuestions: { type: Boolean, default: false }
		},
		isPublished: { type: Boolean, default: false }
	},
	{ timestamps: true }
);

export default mongoose.model('Quiz', QuizSchema);

/backend/src/models/Result.js:

import mongoose from 'mongoose';

const AnswerSchema = new mongoose.Schema(
	{
		questionId: { type: mongoose.Schema.Types.ObjectId, required: true },
		selectedOptionIndex: { type: Number, required: true }
	},
	{ _id: false }
);

const ResultSchema = new mongoose.Schema(
	{
		quiz: { type: mongoose.Schema.Types.ObjectId, ref: 'Quiz', required: true, index: true },
		user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
		answers: { type: [AnswerSchema], default: [] },
		score: { type: Number, default: 0 },
		startedAt: { type: Date },
		submittedAt: { type: Date }
	},
	{ timestamps: true }
);

ResultSchema.index({ quiz: 1, user: 1 }, { unique: false });

export default mongoose.model('Result', ResultSchema);

/backend/src/models/User.js:

import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const UserSchema = new mongoose.Schema(
	{
		name: { type: String, required: true, trim: true },
		email: { type: String, required: true, unique: true, lowercase: true, index: true },
		passwordHash: { type: String, required: true },
		role: { type: String, enum: ['admin', 'teacher', 'student'], default: 'student', index: true },
		avatarUrl: { type: String }
	},
	{ timestamps: true }
);

UserSchema.methods.comparePassword = async function (candidatePassword) {
	return bcrypt.compare(candidatePassword, this.passwordHash);
};

UserSchema.statics.hashPassword = async function (plainPassword) {
	const salt = await bcrypt.genSalt(10);
	return bcrypt.hash(plainPassword, salt);
};

export default mongoose.model('User', UserSchema);

/backend/src/routes/assignment.routes.js:
import { Router } from 'express';
import { authenticate, authorizeRoles } from '../middleware/auth.js';
import { createAssignment, deleteAssignment, listAssignments, validateAssignment } from '../controllers/assignment.controller.js';

const router = Router();

router.use(authenticate);

router.get('/', listAssignments);
router.post('/', authorizeRoles('teacher', 'admin'), validateAssignment, createAssignment);
router.delete('/:id', authorizeRoles('teacher', 'admin'), deleteAssignment);

export default router;


/backend/src/routes/auth.routes.js:
import { Router } from 'express';
import { authenticate } from '../middleware/auth.js';
import { login, me, register, updateMe, validateLogin, validateRegister, validateUpdateMe } from '../controllers/auth.controller.js';

const router = Router();

router.post('/register', validateRegister, register);
router.post('/login', validateLogin, login);
router.get('/me', authenticate, me);
router.patch('/me', authenticate, validateUpdateMe, updateMe);

export default router;

/backend/src/routes/public.routes.js:
import { Router } from 'express';
import { listPublicQuizzes } from '../controllers/public.controller.js';

const router = Router();

router.get('/quizzes', listPublicQuizzes);

export default router;

/backend/src/routes/quiz.routes.js:

import { Router } from 'express';
import { authenticate, authorizeRoles } from '../middleware/auth.js';
import { createQuiz, deleteQuiz, getQuiz, listQuizzes, updateQuiz, validateQuiz } from '../controllers/quiz.controller.js';

const router = Router();

router.use(authenticate);

router.get('/', listQuizzes);
router.get('/:id', getQuiz);
router.post('/', authorizeRoles('teacher', 'admin'), validateQuiz, createQuiz);
router.patch('/:id', authorizeRoles('teacher', 'admin'), updateQuiz);
router.delete('/:id', authorizeRoles('teacher', 'admin'), deleteQuiz);

export default router;

/backend/src/routes/result.routes.js:

import { Router } from 'express';
import { authenticate, authorizeRoles } from '../middleware/auth.js';
import { myResults, resultsForQuiz, submitResult, validateSubmission } from '../controllers/result.controller.js';

const router = Router();

router.use(authenticate);

router.get('/my', myResults);
router.get('/quiz/:quizId', authorizeRoles('teacher', 'admin'), resultsForQuiz);
router.post('/submit', validateSubmission, submitResult);

export default router;

/backend/src/routes/user.routes.js:

import { Router } from 'express';
import { authenticate, authorizeRoles } from '../middleware/auth.js';
import { deleteUser, listUsers, updateUser } from '../controllers/user.controller.js';

const router = Router();

router.use(authenticate, authorizeRoles('admin'));

router.get('/', listUsers);
router.patch('/:id', updateUser);
router.delete('/:id', deleteUser);

export default router;

/backend/src/server.js:

import express from 'express';
import dotenv from 'dotenv';
import cors from 'cors';
import morgan from 'morgan';
import cookieParser from 'cookie-parser';
import { connectToDatabase } from './config/db.js';
import authRoutes from './routes/auth.routes.js';
import userRoutes from './routes/user.routes.js';
import quizRoutes from './routes/quiz.routes.js';
import assignmentRoutes from './routes/assignment.routes.js';
import resultRoutes from './routes/result.routes.js';
import publicRoutes from './routes/public.routes.js';
import { notFoundHandler, errorHandler } from './middleware/error.js';

dotenv.config();

const app = express();

// Middleware
app.use(express.json({ limit: '1mb' }));
app.use(cookieParser());

const clientOrigin = process.env.CLIENT_ORIGIN || 'http://localhost:5173';
app.use(
	cors({
		origin: clientOrigin,
		credentials: true
	})
);

if (process.env.NODE_ENV !== 'test') {
	app.use(morgan('dev'));
}

// Health check
app.get('/api/health', (_req, res) => {
	res.json({ ok: true, service: 'quiz-master-backend' });
});

// Routes
app.use('/api/public', publicRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/quizzes', quizRoutes);
app.use('/api/assignments', assignmentRoutes);
app.use('/api/results', resultRoutes);

// Errors
app.use(notFoundHandler);
app.use(errorHandler);

const PORT = process.env.PORT || 5000;

// Start
connectToDatabase()
	.then(() => {
		app.listen(PORT, () => {
			// eslint-disable-next-line no-console
			console.log(`Server running on port ${PORT}`);
		});
	})
	.catch((err) => {
		// eslint-disable-next-line no-console
		console.error('Failed to start server:', err.message);
		process.exit(1);
	});

export default app;

/backend/.env:

PORT=5000
MONGODB_URI=mongodb://localhost:27017/quiz_master
JWT_SECRET=change_this_secret
CLIENT_ORIGIN=http://localhost:5173

/backend/package.json:

{
  "name": "quiz-master-backend",
  "version": "1.0.0",
  "description": "Backend API for Quiz Master (Node.js + Express + MongoDB)",
  "main": "src/server.js",
  "type": "module",
  "scripts": {
    "dev": "nodemon src/server.js",
    "start": "node src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-validator": "^7.2.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.6.1",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.7"
  }
}



